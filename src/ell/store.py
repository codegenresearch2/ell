import abc\nfrom contextlib import contextmanager\nfrom datetime import datetime\nfrom typing import Any, Optional, Dict, List, Set\n\nclass Store(abc.ABC):\n    \"\"\"Abstract base class for serializers. Defines the interface for serializing and deserializing LMPs and invocations.\"\"\"\n    def __init__(self, has_blob_storage: bool = False):\n        \"\"\"\n        Initializes the Store instance with the option to include blob storage functionality.\"\"\"\n        self.has_blob_storage = has_blob_storage\n\n    @abc.abstractmethod\n    def write_lmp(self, serialized_lmp: 'SerializedLMP', uses: Dict[str, Any]) -> Optional[Any]:\n        \"\"\"Write an LMP (Language Model Package) to the storage.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def write_invocation(self, invocation: 'Invocation', consumes: Set[str]) -> Optional[Any]:\n        \"\"\"Write an invocation of an LMP to the storage.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_cached_invocations(self, lmp_id: str, state_cache_key: str) -> List['Invocation']:\n        \"\"\"Get cached invocations for a given LMP and state cache key.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_versions_by_fqn(self, fqn: str) -> List['SerializedLMP']:\n        \"\"\"Get all versions of an LMP by its fully qualified name.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_lmps(self, skip: int = 0, limit: int = 10, subquery=None, **filters: Optional[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        \"\"\"Retrieve LMPs from the storage.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_invocations(self, lmp_filters: Dict[str, Any], skip: int = 0, limit: int = 10, filters: Optional[Dict[str, Any]] = None, hierarchical: bool = False) -> List[Dict[str, Any]]:\n        \"\"\"Retrieve invocations of an LMP from the storage.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_latest_lmps(self, skip: int = 0, limit: int = 10) -> List[Dict[str, Any]]:\n        \"\"\"Retrieve the latest versions of all LMPs from the storage.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_traces(self) -> List[Dict[str, Any]]:\n        \"\"\"Retrieve all traces from the storage.\"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_all_traces_leading_to(self, invocation_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Retrieve all traces leading to a specific invocation.\"\"\"\n        pass\n\n    @contextmanager\n    def freeze(self, *lmps: 'InvocableLM'):\n        \"\"\"A context manager for caching operations using a particular store.\"\"\"\n        old_cache_values = {}\n        try:\n            for lmp in lmps:\n                old_cache_values[lmp] = getattr(lmp, '__ell_use_cache__', None)\n                setattr(lmp, '__ell_use_cache__', self)\n            yield\n        finally:\n            for lmp in lmps:\n                if lmp in old_cache_values:\n                    setattr(lmp, '__ell_use_cache__', old_cache_values[lmp])\n                else:\n                    delattr(lmp, '__ell_use_cache__')\n