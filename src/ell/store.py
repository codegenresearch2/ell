from abc import ABC, abstractmethod\\\nfrom contextlib import contextmanager\\\\\nfrom datetime import datetime\\\\nfrom typing import Any, Optional, Dict, List, Set, Union\\\\nfrom ell._lstr import _lstr\\\\nfrom ell.types import SerializedLMP, Invocation\\\\nfrom ell.types.message import InvocableLM\\\\n\\nclass Store(ABC):\\\\\n    def __init__(self, has_blob_storage: bool = False):\\\\\n        self.has_blob_storage = has_blob_storage\\\\\n\\n    @abstractmethod\\\\\n    def write_lmp(self, serialized_lmp: SerializedLMP, uses: Dict[str, Any]) -> Optional[Any]:\\\\\n        pass\\\\\n\\n    @abstractmethod\\\\\n    def write_invocation(self, invocation: Invocation, consumes: Set[str]) -> Optional[Any]:\\\\\n        pass\\\\\n\\n    @abstractmethod\\\\\n    def get_cached_invocations(self, lmp_id: str, state_cache_key: str) -> List[Invocation]:\\\\\n        pass\\\\\n\\n    @abstractmethod\\\\\n    def get_versions_by_fqn(self, fqn: str) -> List[SerializedLMP]:\\\\\n        pass\\\\\n\\n    @contextmanager\\\\\n    def freeze(self, *lmps: InvocableLM):\\\\\n        old_cache_values = {}\\\\\n        try:\\\\\n            for lmp in lmps:\\\\\n                old_cache_values[lmp] = getattr(lmp, '__ell_use_cache__', None)\\\\\n                setattr(lmp, '__ell_use_cache__', self)\\\\\n            yield\\\\\n        finally:\\\\\n            for lmp in lmps:\\\\\n                if lmp in old_cache_values:\\\\\n                    setattr(lmp, '__ell_use_cache__', old_cache_values[lmp])\\\\\n                else:\\\\\n                    delattr(lmp, '__ell_use_cache__')\\\\\n