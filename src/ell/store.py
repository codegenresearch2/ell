from abc import ABC, abstractmethod\\\\nfrom contextlib import contextmanager\\\\\nfrom datetime import datetime\\\\\nfrom typing import Any, Optional, Dict, List, Set, Union\\\\\nfrom ell._lstr import _lstr\\\\\nfrom ell.types import SerializedLMP, Invocation\\\\\nfrom ell.types.message import InvocableLM\\\\\n\\\\nclass Store(ABC):\\\\n    """\\\\n    Abstract base class for serializers.\\\n    Defines the interface for serializing and deserializing LMPs and invocations.\\\n    """\\\\n\\\\n    def __init__(self, has_blob_storage: bool = False):\\\\n        """\\\\n        Initializes the Store instance with the option to enable blob storage.\\\n\\\\n        Args:\\\n            has_blob_storage (bool): Whether the store has blob storage capability.\\\n        """\\\\n        self.has_blob_storage = has_blob_storage\\\\n\\\\n    @abstractmethod\\\\n    def write_lmp(self, serialized_lmp: SerializedLMP, uses: Dict[str, Any]) -> Optional[Any]:\\\\n        """\\\\n        Writes an LMP (Language Model Package) to the storage.\\\n\\\\n        Args:\\\n            serialized_lmp (SerializedLMP): The serialized LMP object.\\\n            uses (Dict[str, Any]): Dictionary of LMPs used by this LMP.\\\n\\\\n        Returns:\\\n            Optional[Any]: Returns the result of the write operation.\\\n        """\\\\n        pass\\\\n\\\\n    @abstractmethod\\\\n    def write_invocation(self, invocation: Invocation, consumes: Set[str]) -> Optional[Any]:\\\\n        """\\\\n        Writes an invocation of an LMP to the storage.\\\n\\\\n        Args:\\\n            invocation (Invocation): The invocation object.\\\n            consumes (Set[str]): Set of invocation IDs consumed by this invocation.\\\n\\\\n        Returns:\\\n            Optional[Any]: Returns the result of the write operation.\\\n        """\\\\n        pass\\\\n\\\\n    @abstractmethod\\\\n    def get_cached_invocations(self, lmp_id: str, state_cache_key: str) -> List[Invocation]:\\\\n        """\\\\n        Gets cached invocations for a given LMP and state cache key.\\\n\\\\n        Args:\\\n            lmp_id (str): The ID of the LMP.\\\n            state_cache_key (str): The state cache key.\\\n\\\\n        Returns:\\\n            List[Invocation]: List of cached invocations.\\\n        """\\\\n        pass\\\\n\\\\n    @abstractmethod\\\\n    def get_versions_by_fqn(self, fqn: str) -> List[SerializedLMP]:\\\\n        """\\\\n        Gets all versions of an LMP by its fully qualified name.\\\n\\\\n        Args:\\\n            fqn (str): The fully qualified name of the LMP.\\\n\\\\n        Returns:\\\n            List[SerializedLMP]: List of serialized LMP versions.\\\n        """\\\\n        pass\\\\n\\\\n    @contextmanager\\\\n    def freeze(self, *lmps: InvocableLM):\\\\n        """\\\\n        A context manager for caching operations using a particular store.\\\n\\\\n        Args:\\\n            *lmps (InvocableLM): InvocableLM objects to freeze.\\\n\\\\n        Yields:\\\n            None\\\\n        """\\\\n        old_cache_values = {}\\\\\n        try:\\\\n            for lmp in lmps:\\\\n                old_cache_values[lmp] = getattr(lmp, '__ell_use_cache__', None)\\\\\n                setattr(lmp, '__ell_use_cache__', self)\\\\\n            yield\\\\n        finally:\\\\n            for lmp in lmps:\\\\n                if lmp in old_cache_values:\\\\n                    setattr(lmp, '__ell_use_cache__', old_cache_values[lmp])\\\\\n                else:\\\\n                    delattr(lmp, '__ell_use_cache__')\\\\\n