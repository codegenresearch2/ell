from dataclasses import dataclass\\nfrom typing import Callable, Dict, List, Union, Any\\nfrom datetime import datetime, timezone\\nfrom sqlmodel import Field, SQLModel, Relationship, JSON\\nimport os\\n\\n_lstr_generic = Union[str, 'lstr']\\n\\n@dataclass\\nclass Message(dict):\\n    role: str\\n    content: _lstr_generic\\n\\nMessageOrDict = Union[Message, Dict[str, str]]\\n\\nChat = List[Message]\\n\\nMultiTurnLMP = Callable[[Chat, Any], Chat]\\n\\nT = TypeVar('T', bound=Any)\nChatLMP = Callable[[Chat, T], Chat]\\n\\nLMP = Union[OneTurn, MultiTurnLMP, ChatLMP]\\n\\ndef utc_now() -> datetime:\\n    """\\n    Returns the current UTC timestamp.\\n    Serializes to ISO-8601.\\n    """\\n    return datetime.now(tz=timezone.utc)\\n\\nclass SerializedLMPUses(SQLModel, table=True):\\n    lmp_user_id: Optional[str] = Field(default=None, foreign_key='SerializedLMP.lmp_id', primary_key=True, index=True)\\n    lmp_using_id: Optional[str] = Field(default=None, foreign_key='SerializedLMP.lmp_id', primary_key=True, index=True)\\n\\nclass UTCTimestamp(types.TypeDecorator[datetime]):\\n    impl = types.TIMESTAMP\\n    def process_result_value(self, value: datetime, dialect: Any):\\n        return value.replace(tzinfo=timezone.utc)\\n\\ndef UTCTimestampField(index: bool = False, **kwargs: Any):\\n    return Field(sa_column=Column(UTCTimestamp(timezone=True), index=index, **kwargs))\\n\\nclass SerializedLMP(SQLModel, table=True):\\n    lmp_id: Optional[str] = Field(default=None, primary_key=True)\\n    name: str = Field(index=True)\\n    source: str\\n    dependencies: str\\n    created_at: datetime = UTCTimestampField(index=True, default=func.now(), nullable=False)\\n    is_lm: bool\\n    lm_kwargs: dict = Field(sa_column=Column(JSON))\\n    invocations: List['Invocation'] = Relationship(back_populates='lmp')\\n    used_by: Optional[List['SerializedLMP']] = Relationship(back_populates='used_by', link_model=SerializedLMPUses, sa_relationship_kwargs=dict(primaryjoin='SerializedLMP.lmp_id==SerializedLMPUses.lmp_user_id', secondaryjoin='SerializedLMP.lmp_id==SerializedLMPUses.lmp_using_id'))\\n    uses: List['SerializedLMP'] = Relationship(back_populates='uses', link_model=SerializedLMPUses, sa_relationship_kwargs=dict(primaryjoin='SerializedLMP.lmp_id==SerializedLMPUses.lmp_using_id', secondaryjoin='SerializedLMP.lmp_id==SerializedLMPUses.lmp_user_id'))\\n    initial_free_vars: dict = Field(default_factory=dict, sa_column=Column(JSON))\\n    initial_global_vars: dict = Field(default_factory=dict, sa_column=Column(JSON))\\n    num_invocations: Optional[int] = Field(default=0)\\n    commit_message: Optional[str] = Field(default=None)\\n    version_number: Optional[int] = Field(default=None)\\n    class Config:\\n        table_name = 'serializedlmp'\\n        unique_together = [('version_number', 'name')]\\n\\nclass InvocationTrace(SQLModel, table=True):\\n    invocation_consumer_id: str = Field(foreign_key='invocation.id', primary_key=True, index=True)\\n    invocation_consuming_id: str = Field(foreign_key='invocation.id', primary_key=True, index=True)\\n\\nclass Invocation(SQLModel, table=True):\\n    id: Optional[str] = Field(default=None, primary_key=True)\\n    lmp_id: str = Field(foreign_key='SerializedLMP.lmp_id', index=True)\\n    args: List[Any] = Field(default_factory=list, sa_column=Column(JSON))\\n    kwargs: dict = Field(default_factory=dict, sa_column=Column(JSON))\\n    global_vars: dict = Field(default_factory=dict, sa_column=Column(JSON))\\n    free_vars: dict = Field(default_factory=dict, sa_column=Column(JSON))\\n    latency_ms: float\\n    prompt_tokens: Optional[int] = Field(default=None)\\n    completion_tokens: Optional[int] = Field(default=None)\\n    state_cache_key: Optional[str] = Field(default=None)\\n    created_at: datetime = UTCTimestampField(default=func.now(), nullable=False)\\n    invocation_kwargs: dict = Field(default_factory=dict, sa_column=Column(JSON))\\n    lmp: SerializedLMP = Relationship(back_populates='invocations')\\n    results: List['SerializedLStr'] = Relationship(back_populates='producer_invocation')\\n    consumed_by: List['Invocation'] = Relationship(back_populates='consumed_by', link_model=InvocationTrace, sa_relationship_kwargs=dict(primaryjoin='Invocation.id==InvocationTrace.invocation_consumer_id', secondaryjoin='Invocation.id==InvocationTrace.invocation_consuming_id'))\\n    consumes: List['Invocation'] = Relationship(back_populates='consumes', link_model=InvocationTrace, sa_relationship_kwargs=dict(primaryjoin='Invocation.id==InvocationTrace.invocation_consuming_id', secondaryjoin='Invocation.id==InvocationTrace.invocation_consumer_id'))\\n\\nclass SerializedLStr(SQLModel, table=True):\\n    id: Optional[int] = Field(default=None, primary_key=True)\\n    content: str\\n    logits: List[float] = Field(default_factory=list, sa_column=Column(JSON))\\n    producer_invocation_id: Optional[int] = Field(default=None, foreign_key='invocation.id', index=True)\\n    producer_invocation: Optional['Invocation'] = Relationship(back_populates='results')\\n    def deserialize(self) -> 'lstr':\\n        return lstr(self.content, logits=self.logits, _origin_trace=frozenset([self.producer_invocation_id]))"}