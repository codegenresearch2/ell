from typing import Optional, List, Dict, Any\"nfrom datetime import datetime\nfrom sqlmodel import Field, SQLModel, Relationship, JSON\nfrom ell.lstr import lstr\n\n_lstr_generic = Optional[lstr]\n\nOneTurn = Callable[..., _lstr_generic]\n\nLMPParams = Dict[str, Any]\n\n@dataclass\nclass Message(dict, metaclass=DictSyncMeta):\n    role: str\n    content: _lstr_generic\n\nMessageOrDict = Union[Message, Dict[str, str]]\n\nChat = List[\n    Message\n]\n\nMultiTurnLMP = Callable[..., Chat]\n\nT = TypeVar('T', bound=Any)\nChatLMP = Callable[[Chat, T], Chat]\n\nLMP = Union[OneTurn, MultiTurnLMP, ChatLMP]\n\nInvocableLM = Callable[..., _lstr_generic]\n\nclass SerializedLMPUses(SQLModel, table=True):\n    lmp_user_id: Optional[str] = Field(default=None, foreign_key='SerializedLMP.lmp_id', primary_key=True)\n    lmp_using_id: Optional[str] = Field(default=None, foreign_key='SerializedLMP.lmp_id', primary_key=True)\n\nclass SerializedLMP(SQLModel, table=True):\n    lmp_id: Optional[str] = Field(default=None, primary_key=True)\n    name: str\n    source: str\n    dependencies: str\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    is_lm: bool\n    lm_kwargs: dict = Field(sa_column=Column(JSON))\n\n    invocations: List['Invocation'] = Relationship(back_populates='lmp')\n    used_by: Optional[List['SerializedLMP']] = Relationship(back_populates='uses', link_model=SerializedLMPUses, sa_relationship_kwargs=dict(primaryjoin='SerializedLMP.lmp_id==SerializedLMPUses.lmp_user_id', secondaryjoin='SerializedLMP.lmp_id==SerializedLMPUses.lmp_using_id'))\n    uses: List['SerializedLMP'] = Relationship(back_populates='used_by', link_model=SerializedLMPUses, sa_relationship_kwargs=dict(primaryjoin='SerializedLMP.lmp_id==SerializedLMPUses.lmp_using_id', secondaryjoin='SerializedLMP.lmp_id==SerializedLMPUses.lmp_user_id'))\n\n    initial_free_vars: dict = Field(default_factory=dict, sa_column=Column(JSON))\n    initial_global_vars: dict = Field(default_factory=dict, sa_column=Column(JSON))\n    num_invocations: Optional[int] = Field(default=0)\n    commit_message: Optional[str] = Field(default=None)\n    version_number: Optional[int] = Field(default=None)\n\n    class Config:\n        table_name = 'serializedlmp'\n        unique_together = [('version_number', 'name')]\n\nclass InvocationTrace(SQLModel, table=True):\n    invocation_consumer_id: str = Field(foreign_key='Invocation.id', primary_key=True)\n    invocation_consuming_id: str = Field(foreign_key='Invocation.id', primary_key=True)\n\nclass Invocation(SQLModel, table=True):\n    id: Optional[str] = Field(default=None, primary_key=True)\n    lmp_id: str = Field(foreign_key='SerializedLMP.lmp_id')\n    args: List[Any] = Field(default_factory=list, sa_column=Column(JSON))\n    kwargs: dict = Field(default_factory=dict, sa_column=Column(JSON))\n\n    global_vars: dict = Field(default_factory=dict, sa_column=Column(JSON))\n    free_vars: dict = Field(default_factory=dict, sa_column=Column(JSON))\n\n    latency_ms: float\n    prompt_tokens: Optional[int] = Field(default=None)\n    completion_tokens: Optional[int] = Field(default=None)\n    state_cache_key: Optional[str] = Field(default=None)\n\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    invocation_kwargs: dict = Field(default_factory=dict, sa_column=Column(JSON))\n\n    lmp: 'SerializedLMP' = Relationship(back_populates='invocations')\n    results: List['SerializedLStr'] = Relationship(back_populates='producer_invocation')\n\n    consumed_by: List['Invocation'] = Relationship(back_populates='consumes', link_model=InvocationTrace, sa_relationship_kwargs=dict(primaryjoin='Invocation.id==InvocationTrace.invocation_consumer_id', secondaryjoin='Invocation.id==InvocationTrace.invocation_consuming_id'))\n    consumes: List['Invocation'] = Relationship(back_populates='consumed_by', link_model=InvocationTrace, sa_relationship_kwargs=dict(primaryjoin='Invocation.id==InvocationTrace.invocation_consuming_id', secondaryjoin='Invocation.id==InvocationTrace.invocation_consumer_id'))\n\nclass SerializedLStr(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    content: str\n    logits: List[float] = Field(default_factory=list, sa_column=Column(JSON))\n    producer_invocation_id: Optional[int] = Field(default=None, foreign_key='Invocation.id')\n    producer_invocation: Optional['Invocation'] = Relationship(back_populates='results')\n\n    def deserialize(self) -> lstr:\n        return lstr(self.content, logits=self.logits, _origin_trace=frozenset([self.producer_invocation_id]))