from dataclasses import dataclass\nfrom typing import Callable, Dict, List, Union\n\nfrom ell.lstr import lstr\nfrom ell.util.dict_sync_meta import DictSyncMeta\n\nimport json\nfrom datetime import datetime\nfrom typing import Any\nfrom sqlmodel import Field, SQLModel, Relationship, JSON\n\n_lstr_generic = Union[lstr, str]\n\nOneTurn = Callable[..., _lstr_generic]\n\nLMPParams = Dict[str, Any]\n\n@dataclass\nclass Message(dict, metaclass=DictSyncMeta):\n    role: str\n    content: _lstr_generic\n\nMessageOrDict = Union[Message, Dict[str, str]]\n\nChat = List[\n    Message\n]  # [{"role": "system", "content": "prompt"}, {"role": "user", "content": "message"}]\n\nMultiTurnLMP = Callable[..., Chat]\nfrom typing import TypeVar, Any\n\nT = TypeVar("T", bound=Any)\nChatLMP = Callable[[Chat, T], Chat]\nLMP = Union[OneTurn, MultiTurnLMP, ChatLMP]\nInvocableLM = Callable[..., _lstr_generic]\n\nclass SerializedLMPUses(SQLModel, table=True):\n    lmp_user_id: Optional[str] = Field(default=None, foreign_key="SerializedLMP.lmp_id", primary_key=True)  # ID of the LMP that is being used\n    lmp_using_id: Optional[str] = Field(default=None, foreign_key="SerializedLMP.lmp_id", primary_key=True)  # ID of the LMP that is using the other LMP\n\nclass SerializedLMP(SQLModel, table=True):\n    lmp_id: Optional[str] = Field(default=None, primary_key=True)  # Unique identifier for the LMP, now an index\n    name: str  # Name of the LMP\n    source: str  # Source code or reference for the LMP\n    dependencies: str  # List of dependencies for the LMP, stored as a string\n    created_at: datetime = Field(default_factory=datetime.utcnow)  # Timestamp of when the LMP was created\n    is_lm: bool  # Boolean indicating if it is an LM (Language Model) or an LMP\n    lm_kwargs: dict  = Field(sa_column=Column(JSON)) # Additional keyword arguments for the LMP\n\n    invocations: List["Invocation"] = Relationship(back_populates="lmp")  # Relationship to invocations of this LMP\n    used_by: Optional[List["SerializedLMP"]] = Relationship(back_populates="uses", link_model=SerializedLMPUses, sa_relationship_kwargs=dict(primaryjoin="SerializedLMP.lmp_id==SerializedLMPUses.lmp_user_id", secondaryjoin="SerializedLMP.lmp_id==SerializedLMPUses.lmp_using_id"),)\n    uses: List["SerializedLMP"]  = Relationship(back_populates="used_by", link_model=SerializedLMPUses, sa_relationship_kwargs=dict(primaryjoin="SerializedLMP.lmp_id==SerializedLMPUses.lmp_using_id", secondaryjoin="SerializedLMP.lmp_id==SerializedLMPUses.lmp_user_id"),)\n\n    initial_free_vars : dict = Field(default_factory=dict, sa_column=Column(JSON))\n    initial_global_vars : dict = Field(default_factory=dict, sa_column=Column(JSON))\n    num_invocations : Optional[int] = Field(default=0)\n    commit_message : Optional[str] = Field(default=None)\n    version_number: Optional[int] = Field(default=None)\n\n    class Config:\n        table_name = "serializedlmp"\n        unique_together = [("version_number", "name")]\n\nclass InvocationTrace(SQLModel, table=True):\n    invocation_consumer_id: str = Field(foreign_key="Invocation.id", primary_key=True)  # ID of the Invocation that is consuming another Invocation\n    invocation_consuming_id: str = Field(foreign_key="Invocation.id", primary_key=True)  # ID of the Invocation that is being consumed by another Invocation\n\nclass Invocation(SQLModel, table=True):\n    id: Optional[str] = Field(default=None, primary_key=True)  # Unique identifier for the invocation\n    lmp_id: str = Field(foreign_key="SerializedLMP.lmp_id")  # ID of the LMP that was invoked\n    args: List[Any] = Field(default_factory=list, sa_column=Column(JSON))  # Arguments used in the invocation\n    kwargs: dict = Field(default_factory=dict, sa_column=Column(JSON))  # Keyword arguments used in the invocation\n\n    global_vars : dict = Field(default_factory=dict, sa_column=Column(JSON))  # Global variables used in the invocation\n    free_vars : dict = Field(default_factory=dict, sa_column=Column(JSON))  # Free variables used in the invocation\n\n    latency_ms : float \n    prompt_tokens: Optional[int] = Field(default=None)\n    completion_tokens: Optional[int] = Field(default=None)\n    state_cache_key: Optional[str] = Field(default=None)\n\n    created_at: datetime = Field(default_factory=datetime.utcnow)  # Timestamp of when the invocation was created\n    invocation_kwargs: dict = Field(default_factory=dict, sa_column=Column(JSON))  # Additional keyword arguments for the invocation\n\n    lmp: SerializedLMP = Relationship(back_populates="invocations")  # Relationship to the LMP that was invoked\n    results: List["SerializedLStr"] = Relationship(back_populates="producer_invocation")  # Relationship to the LStr results of the invocation\n\n    consumed_by: List["Invocation"] = Relationship(back_populates="consumes", link_model=InvocationTrace, sa_relationship_kwargs=dict(primaryjoin="Invocation.id==InvocationTrace.invocation_consumer_id", secondaryjoin="Invocation.id==InvocationTrace.invocation_consuming_id"),)\n    consumes: List["Invocation"] = Relationship(back_populates="consumed_by", link_model=InvocationTrace, sa_relationship_kwargs=dict(primaryjoin="Invocation.id==InvocationTrace.invocation_consuming_id", secondaryjoin="Invocation.id==InvocationTrace.invocation_consumer_id"),)\n\nclass SerializedLStr(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)  # Unique identifier for the LStr\n    content: str  # The actual content of the LStr\n    logits: List[float] = Field(default_factory=list, sa_column=Column(JSON))  # Logits associated with the LStr, if available\n    producer_invocation_id: Optional[int] = Field(default=None, foreign_key="Invocation.id")  # ID of the Invocation that produced this LStr\n    producer_invocation: Optional["Invocation"] = Relationship(back_populates="results")  # Relationship to the Invocation that produced this LStr\n\n    def deserialize(self) -> lstr:\n        return lstr(self.content, logits=self.logits, _origin_trace=frozenset([self.producer_invocation_id]))\n