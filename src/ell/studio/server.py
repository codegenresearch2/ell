from typing import Optional, Dict, Any\\\nfrom sqlmodel import Session\\\nfrom ell.stores.sql import PostgresStore, SQLiteStore\\\nfrom ell import __version__\\\nfrom fastapi import FastAPI, Query, HTTPException, Depends, Response, WebSocket, WebSocketDisconnect\\\nfrom fastapi.middleware.cors import CORSMiddleware\\\nimport logging\\\nimport json\\\nfrom ell.studio.config import Config\\\nfrom ell.studio.connection_manager import ConnectionManager\\\nfrom ell.studio.datamodels import InvocationPublicWithConsumes, SerializedLMPWithUses\\\nfrom ell.types import SerializedLMP\\\nfrom datetime import datetime, timedelta\\\nfrom sqlmodel import select\\\n\\\nlogger = logging.getLogger(__name__)\\\n\\\ndef get_serializer(config: Config):\\\n    if config.pg_connection_string:\\\n        return PostgresStore(config.pg_connection_string)\\\n    elif config.storage_dir:\\\n        return SQLiteStore(config.storage_dir)\\\n    else:\\\n        raise ValueError("No storage configuration found")\\\n\\\ndef create_app(config: Config):\\\n    serializer = get_serializer(config)\\\n\\\n    def get_session():\\\n        with Session(serializer.engine) as session:\\\n            yield session\\\n\\\n    app = FastAPI(title="ell Studio", version=__version__)\\\n\\\n    # Enable CORS for all origins\\\n    app.add_middleware(\\\n        CORSMiddleware,\\\n        allow_origins=["*"],\\\n        allow_credentials=True,\\\n        allow_methods=["*"],\\\n        allow_headers=["*"],\\\n    )\\\n\\\n    manager = ConnectionManager()\\\n\\\n    @app.websocket("/ws")\\\n    async def websocket_endpoint(websocket: WebSocket):\\\n        await manager.connect(websocket)\\\n        try:\\\n            while True:\\\n                data = await websocket.receive_text()\\\n                # Handle incoming WebSocket messages if needed\\\n        except WebSocketDisconnect:\\\n            manager.disconnect(websocket)\\\n\\\n    @app.get("/api/latest/lmps", response_model=list[SerializedLMPWithUses])\\\n    def get_latest_lmps(\\\n        skip: int = Query(0, ge=0),\\\n        limit: int = Query(100, ge=1, le=100),\\\n        session: Session = Depends(get_session)\\\n    ):\\\n        lmps = serializer.get_latest_lmps(\\\n            session,\\\n            skip=skip, limit=limit,\\\n            )\\\n        return lmps\\\n\\\n    # TOOD: Create a get endpoint to efficient get on the index with /api/lmp/<lmp_id>\\\n    @app.get("/api/lmp/{lmp_id}")\\\n    def get_lmp_by_id(lmp_id: str, session: Session = Depends(get_session)):\\\n        lmp = serializer.get_lmps(session, lmp_id=lmp_id)[0]\\\n        return lmp\\\n\\\n    @app.get("/api/lmps", response_model=list[SerializedLMPWithUses])\\\n    def get_lmp(\\\n        lmp_id: Optional[str] = Query(None),\\\n        name: Optional[str] = Query(None),\\\n        skip: int = Query(0, ge=0),\\\n        limit: int = Query(100, ge=1, le=100),\\\n        session: Session = Depends(get_session)\\\n    ):\\\n        filters : Dict[str, Any] = {}\\\n        if name:\\\n            filters['name'] = name\\\n        if lmp_id:\\\n            filters['lmp_id'] = lmp_id\\\n\\\n        lmps = serializer.get_lmps(session, skip=skip, limit=limit, **filters) \\\n        if not lmps:\\\n            raise HTTPException(status_code=404, detail="LMP not found")\\\n        return lmps\\\n\\\n    @app.get("/api/invocation/{invocation_id}", response_model=InvocationPublicWithConsumes)\\\n    def get_invocation(\\\n        invocation_id: str,\\\n        session: Session = Depends(get_session)\\\n    ):\\\n        invocation = serializer.get_invocations(session, lmp_filters=dict(), filters={"id": invocation_id})[0]\\\n        return invocation\\\n\\\n    @app.get("/api/invocations", response_model=list[InvocationPublicWithConsumes])\\\n    def get_invocations(\\\n        id: Optional[str] = Query(None),\\\n        hierarchical: Optional[bool] = Query(False),\\\n        skip: int = Query(0, ge=0),\\\n        limit: int = Query(100, ge=1, le=100),\\\n        lmp_name: Optional[str] = Query(None),\\\n        lmp_id: Optional[str] = Query(None),\\\n        session: Session = Depends(get_session)\\\n    ):\\\n        lmp_filters = {}\\\n        if lmp_name:\\\n            lmp_filters["name"] = lmp_name\\\n        if lmp_id:\\\n            lmp_filters["lmp_id"] = lmp_id\\\n\\\n        invocation_filters = {}\\\n        if id:\\\n            invocation_filters["id"] = id\\\n\\\n        invocations = serializer.get_invocations(\\\n            session,\\\n            lmp_filters=lmp_filters,\\\n            filters=invocation_filters,\\\n            skip=skip,\\\n            limit=limit,\\\n            hierarchical=hierarchical\\\n        )\\\n        return invocations\\\n\\\n    @app.get("/api/traces")\\\n    def get_consumption_graph(\\\n        session: Session = Depends(get_session)\\\n    ):\\\n        traces = serializer.get_traces(session)\\\n        return traces\\\n\\\n    @app.get("/api/traces/{invocation_id}")\\\n    def get_all_traces_leading_to(\\\n        invocation_id: str,\\\n        session: Session = Depends(get_session)\\\n    ):\\\n        traces = serializer.get_all_traces_leading_to(session, invocation_id)\\\n        return traces\\\n\\\n    @app.get("/api/blob/{blob_id}", response_class=Response)\\\n    def get_blob(\\\n        blob_id: str,\\\n        session: Session = Depends(get_session)\\\n    ):\\\n        blob = serializer.read_external_blob(blob_id)\\\n        return Response(content=blob, media_type="application/json")\\\n\\\n    @app.get("/api/lmp-history")\\\n    def get_lmp_history(\\\n        days: int = Query(365, ge=1, le=3650),  # Default to 1 year, max 10 years\\\n        session: Session = Depends(get_session)\\\n    ):\\\n        # Calculate the start date\\\n        start_date = datetime.utcnow() - timedelta(days=days)\\\n\\\n        # Query to get all LMP creation times within the date range\\\n        query = (\\\n            select(SerializedLMP.created_at)\\\n            .where(SerializedLMP.created_at >= start_date)\\\n            .order_by(SerializedLMP.created_at)\\\n        )\\\n\\\n        results = session.exec(query).all()\\\n\\\n        # Convert results to a list of dictionaries\\\n        history = [{"date": str(row), "count": 1} for row in results]\\\n\\\n        return history\\\n\\\n    async def notify_clients(entity: str, id: Optional[str] = None):\\\n        message = json.dumps({"entity": entity, "id": id})\\\n        await manager.broadcast(message)\\\n\\\n    # Add this method to the app object\\\n    app.notify_clients = notify_clients\\\n\\\n    @app.get("/api/invocations/aggregate", response_model=InvocationsAggregate)\\\n    def get_invocations_aggregate(\\\n        lmp_name: Optional[str] = Query(None),\\\n        lmp_id: Optional[str] = Query(None),\\\n        days: int = Query(30, ge=1, le=365),\\\n        session: Session = Depends(get_session)\\\n    ):\\\n        lmp_filters = {}\\\n        if lmp_name:\\\n            lmp_filters["name"] = lmp_name\\\n        if lmp_id:\\\n            lmp_filters["lmp_id"] = lmp_id\\\n\\\n        aggregate_data = serializer.get_invocations_aggregate(session, lmp_filters=lmp_filters, days=days)\\\n        return InvocationsAggregate(**aggregate_data)\\\n\\\n    return app