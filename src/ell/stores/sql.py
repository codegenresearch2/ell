import json\"import os\"import typing\"import pydantic\"import sqlmodel\"import ell.store\"import cattrs\"import numpy as np\"from sqlalchemy.sql import text\"from ell.types import InvocationTrace, SerializedLMP, Invocation, InvocationContents\"from ell._lstr import _lstr\"from sqlalchemy import or_, func, and_, extract, FromClause\"from sqlalchemy.types import TypeDecorator, VARCHAR\"from ell.types.lmp import SerializedLMPUses, utc_now\"from ell.util.serialization import pydantic_ltype_aware_cattr\"import gzip\"import json\n\nclass SQLStore(ell.store.Store):\n    def __init__(self, db_uri: str, has_blob_storage: bool = False):\n        self.engine = create_engine(db_uri, json_serializer=lambda obj: json.dumps(pydantic_ltype_aware_cattr.unstructure(obj), sort_keys=True, default=repr))\n        SQLModel.metadata.create_all(self.engine)\n        self.open_files = {}\n        super().__init__(has_blob_storage)\n\n    def write_lmp(self, serialized_lmp: SerializedLMP, uses: Dict[str, Any]) -> None:\n        with Session(self.engine) as session:\n            lmp = session.exec(select(SerializedLMP).filter(SerializedLMP.lmp_id == serialized_lmp.lmp_id)).first()\n            if not lmp:\n                session.add(serialized_lmp)\n            for use_id in uses:\n                used_lmp = session.exec(select(SerializedLMP).where(SerializedLMP.lmp_id == use_id)).first()\n                if used_lmp:\n                    serialized_lmp.uses.append(used_lmp)\n            session.commit()\n        return None\n\n    # Implement other methods similarly...