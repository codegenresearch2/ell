import sqlite3\\\nfrom typing import Optional, Any, Dict, List, Set\\\nfrom sqlmodel import Session, SQLModel, create_engine\\\nimport ell.store\\\nimport cattrs\\\nimport numpy as np\\\nfrom sqlalchemy.sql import text\\\n\\nclass SQLStore(ell.store.Store):\\\n    def __init__(self, db_uri: str):\\\n        self.engine = create_engine(db_uri)\\\n        SQLModel.metadata.create_all(self.engine)\\\n        self.open_files: Dict[str, Dict[str, Any]] = {}\\\n\\n    def write_lmp(self, serialized_lmp: 'SerializedLMP', uses: Dict[str, Any]) -> Optional[Any]:\\\n        with Session(self.engine) as session:\\\n            lmp = session.query(SerializedLMP).filter(SerializedLMP.lmp_id == serialized_lmp.lmp_id).first()\\\n            if lmp:\\\n                return lmp\\\n            else:\\\n                session.add(serialized_lmp)\\\n            for use_id in uses:\\\n                used_lmp = session.exec(select(SerializedLMP).where(SerializedLMP.lmp_id == use_id)).first()\\\n                if used_lmp:\\\n                    serialized_lmp.uses.append(used_lmp)\\\n            session.commit()\\\n        return None\\\n\\n    def write_invocation(self, invocation: 'Invocation', results: List['SerializedLStr'], consumes: Set[str]) -> Optional[Any]:\\\n        with Session(self.engine) as session:\\\n            lmp = session.query(SerializedLMP).filter(SerializedLMP.lmp_id == invocation.lmp_id).first()\\\n            assert lmp is not None, f"LMP with id {invocation.lmp_id} not found. Writing invocation erroneously"\\\n            if lmp.num_invocations is None:\\\n                lmp.num_invocations = 1\\\n            else:\\\n                lmp.num_invocations += 1\\\n            session.add(invocation)\\\n            for result in results:\\\n                result.producer_invocation = invocation\\\n                session.add(result)\\\n            for consumed_id in consumes:\\\n                session.add(InvocationTrace(invocation_consumer_id=invocation.id, invocation_consuming_id=consumed_id))\\\n            session.commit()\\\n        return None\\\n\\n    def get_cached_invocations(self, lmp_id: str, state_cache_key: str) -> List['Invocation']:\\\n        with Session(self.engine) as session:\\\n            return self.get_invocations(session, lmp_filters={"lmp_id": lmp_id}, filters={"state_cache_key": state_cache_key})\\\n\\n    def get_versions_by_fqn(self, fqn: str) -> List['SerializedLMP']:\\\n        with Session(self.engine) as session:\\\n            return self.get_lmps(session, name=fqn)\\\n\\n    def get_latest_lmps(self, skip: int = 0, limit: int = 10) -> List[Dict[str, Any]]:\\\n        with Session(self.engine) as session:\\\n            subquery = (\\\n                select(SerializedLMP.name, func.max(SerializedLMP.created_at).label("max_created_at"))\\\n                .group_by(SerializedLMP.name)\\\n                .subquery()\\\n            )\\\n            filters = {\\\n                "name": subquery.c.name,\\\n                "created_at": subquery.c.max_created_at\\\n            }\\\n            return self.get_lmps(session, skip=skip, limit=limit, subquery=subquery, **filters)\\\n\\n    def get_lmps(self, session: Session, skip: int = 0, limit: int = 10, subquery=None, **filters: Optional[Dict[str, Any]]) -> List[Dict[str, Any]]:\\\n        query = select(SerializedLMP)\\\n        if subquery is not None:\\\n            query = query.join(subquery, and_(SerializedLMP.name == subquery.c.name, SerializedLMP.created_at == subquery.c.max_created_at))\\\n        if filters:\\\n            for key, value in filters.items():\\\n                query = query.where(getattr(SerializedLMP, key) == value)\\\n        query = query.order_by(SerializedLMP.created_at.desc()).offset(skip).limit(limit)\\\n        results = session.exec(query).all()\\\n        return [result.model_dump() for result in results]\\\n\\n    def get_invocations(self, session: Session, lmp_filters: Dict[str, Any], skip: int = 0, limit: int = 10, filters: Optional[Dict[str, Any]] = None, hierarchical: bool = False) -> List[Dict[str, Any]]:\\\n        def fetch_invocation(inv_id):\\\n            query = (\\\n                select(Invocation, SerializedLStr, SerializedLMP)\\\n                .join(SerializedLMP)\\\n                .outerjoin(SerializedLStr)\\\n                .where(Invocation.id == inv_id)\\\n            )\\\n            results = session.exec(query).all()\\\n            if not results:\\\n                return None\\\n            inv, lstr, lmp = results[0]\\\n            inv_dict = inv.model_dump()\\\n            inv_dict['lmp'] = lmp.model_dump()\\\n            inv_dict['results'] = [dict(**l.model_dump(), __lstr=True) for l in [r[1] for r in results if r[1]]]\\\n            consumes_query = select(InvocationTrace.invocation_consuming_id).where(InvocationTrace.invocation_consumer_id == inv_id)\\\n            consumed_by_query = select(InvocationTrace.invocation_consumer_id).where(InvocationTrace.invocation_consuming_id == inv_id)\\\n            inv_dict['consumes'] = [r for r in session.exec(consumes_query).all()]\\\n            inv_dict['consumed_by'] = [r for r in session.exec(consumed_by_query).all()]\\\n            inv_dict['uses'] = list([d.id for d in inv.uses]) \\\n            return inv_dict\\\n\\n        query = select(Invocation.id).join(SerializedLMP)\\\n        for key, value in lmp_filters.items():\\\n            query = query.where(getattr(SerializedLMP, key) == value)\\\n        if filters:\\\n            for key, value in filters.items():\\\n                query = query.where(getattr(Invocation, key) == value)\\\n        query = query.order_by(Invocation.created_at.desc()).offset(skip).limit(limit)\\\n        invocation_ids = session.exec(query).all()\\\n        invocations = [fetch_invocation(inv_id) for inv_id in invocation_ids if inv_id]\\\n        if hierarchical:\\\n            used_ids = set()\\\n            for inv in invocations:\\\n                used_ids.update(inv['uses'])\\\n            used_invocations = [fetch_invocation(inv_id) for inv_id in used_ids if inv_id not in invocation_ids]\\\n            invocations.extend(used_invocations)\\\n        return invocations\\\n\\n    def get_traces(self, session: Session) -> List[Dict[str, Any]]:\\\n        query = text(\"""\\\n        SELECT \\\n            consumer.lmp_id, \\\n            trace.*, \\\n            consumed.lmp_id\\\n        FROM \\\n            invocation AS consumer\\\n        JOIN \\\n            invocationtrace AS trace ON consumer.id = trace.invocation_consumer_id\\\n        JOIN \\\n            invocation AS consumed ON trace.invocation_consuming_id = consumed.id\\\n        """)\\\n        results = session.exec(query).all()\\\n        traces = []\\\n        for (consumer_lmp_id, consumer_invocation_id, consumed_invocation_id, consumed_lmp_id) in results:\\\n            traces.append({\\\n                'consumer': consumer_lmp_id,\\\n                'consumed': consumed_lmp_id\\\n            })\\\n        return traces\\\n\\n    def get_all_traces_leading_to(self, session: Session, invocation_id: str) -> List[Dict[str, Any]]:\\\n        traces = []\\\n        visited = set()\\\n        queue = [(invocation_id, 0)]\\\n\\n        while queue:\\\n            current_invocation_id, depth = queue.pop(0)\\\n            if depth > 4:\\\n                continue\\\n            if current_invocation_id in visited:\\\n                continue\\\n            visited.add(current_invocation_id)\\\n            results = session.exec(\\\n                select(InvocationTrace, Invocation, SerializedLMP)\\\n                .join(Invocation, InvocationTrace.invocation_consuming_id == Invocation.id)\\\n                .join(SerializedLMP, Invocation.lmp_id == SerializedLMP.lmp_id)\\\n                .where(InvocationTrace.invocation_consumer_id == current_invocation_id)\\\n            ).all()\\\n            for row in results:\\\n                trace = {\\\n                    'consumer_id': row.InvocationTrace.invocation_consumer_id,\\\n                    'consumed': {key: value for key, value in row.Invocation.__dict__.items() if key not in ['invocation_consumer_id', 'invocation_consuming_id']},\\\n                    'consumed_lmp': row.SerializedLMP.model_dump()\\\n                }\\\n                traces.append(trace)\\\n                queue.append((row.Invocation.id, depth + 1))\\\n        unique_traces = {}\\\n        for trace in traces:\\\n            consumed_id = trace['consumed']['id']\\\n            if consumed_id not in unique_traces:\\\n                unique_traces[consumed_id] = trace\\\n        return list(unique_traces.values())